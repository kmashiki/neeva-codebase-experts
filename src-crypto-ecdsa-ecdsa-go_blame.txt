f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500   1) // Copyright 2011 The Go Authors. All rights reserved.
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500   2) // Use of this source code is governed by a BSD-style
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500   3) // license that can be found in the LICENSE file.
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500   4) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500   5) // Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400   6) // defined in FIPS 186-4 and SEC 1, Version 2.0.
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800   7) //
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400   8) // Signatures generated by this package are not deterministic, but entropy is
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400   9) // mixed with the private key and the message, achieving the same level of
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  10) // security in case of randomness source failure.
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  11) package ecdsa
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  12) 
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  13) // [FIPS 186-4] references ANSI X9.62-2005 for the bulk of the ECDSA algorithm.
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  14) // That standard is not freely available, which is a problem in an open source
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  15) // implementation, because not only the implementer, but also any maintainer,
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  16) // contributor, reviewer, auditor, and learner needs access to it. Instead, this
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  17) // package references and follows the equivalent [SEC 1, Version 2.0].
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  18) //
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  19) // [FIPS 186-4]: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  20) // [SEC 1, Version 2.0]: https://www.secg.org/sec1-v2.pdf
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  21) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  22) import (
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700  23) 	"crypto"
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800  24) 	"crypto/aes"
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800  25) 	"crypto/cipher"
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  26) 	"crypto/elliptic"
7e5bc4775f1 src/crypto/ecdsa/ecdsa.go     (<billo@ca.ibm.com>    2019-05-16 12:45:52 -0400  27) 	"crypto/internal/randutil"
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800  28) 	"crypto/sha512"
d7c699d9935 src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-04-05 20:40:40 +0000  29) 	"errors"
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  30) 	"io"
30aa701fec9 src/pkg/crypto/ecdsa/ecdsa.go (<r@golang.org>        2011-11-08 15:40:58 -0800  31) 	"math/big"
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500  32) 
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500  33) 	"golang.org/x/crypto/cryptobyte"
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500  34) 	"golang.org/x/crypto/cryptobyte/asn1"
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  35) )
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  36) 
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  37) // A invertible implements fast inverse in GF(N).
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700  38) type invertible interface {
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  39) 	// Inverse returns the inverse of k mod Params().N.
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700  40) 	Inverse(k *big.Int) *big.Int
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700  41) }
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700  42) 
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  43) // A combinedMult implements fast combined multiplication for verification.
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700  44) type combinedMult interface {
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  45) 	// CombinedMult returns [s1]G + [s2]P where G is the generator.
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400  46) 	CombinedMult(Px, Py *big.Int, s1, s2 []byte) (x, y *big.Int)
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700  47) }
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700  48) 
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800  49) const (
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800  50) 	aesIV = "IV for ECDSA CTR"
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800  51) )
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800  52) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  53) // PublicKey represents an ECDSA public key.
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  54) type PublicKey struct {
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500  55) 	elliptic.Curve
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  56) 	X, Y *big.Int
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  57) }
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  58) 
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  59) // Any methods implemented on PublicKey might need to also be implemented on
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  60) // PrivateKey, as the latter embeds the former and will expose its methods.
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  61) 
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  62) // Equal reports whether pub and x have the same value.
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  63) //
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  64) // Two keys are only considered to have the same value if they have the same Curve value.
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  65) // Note that for example elliptic.P256() and elliptic.P256().Params() are different
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  66) // values, as the latter is a generic not constant time implementation.
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  67) func (pub *PublicKey) Equal(x crypto.PublicKey) bool {
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  68) 	xx, ok := x.(*PublicKey)
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  69) 	if !ok {
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  70) 		return false
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  71) 	}
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  72) 	return pub.X.Cmp(xx.X) == 0 && pub.Y.Cmp(xx.Y) == 0 &&
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  73) 		// Standard library Curve implementations are singletons, so this check
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  74) 		// will work for those. Other Curves might be equivalent even if not
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  75) 		// singletons, but there is no definitive way to check for that, and
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  76) 		// better to err on the side of safety.
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  77) 		pub.Curve == xx.Curve
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  78) }
b5f2c0f5029 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-03-17 20:34:51 -0400  79) 
5a986eca869 src/crypto/ecdsa/ecdsa.go     (<namusyaka@gmail.com> 2017-09-15 10:24:47 +0900  80) // PrivateKey represents an ECDSA private key.
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  81) type PrivateKey struct {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  82) 	PublicKey
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  83) 	D *big.Int
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  84) }
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500  85) 
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700  86) // Public returns the public key corresponding to priv.
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700  87) func (priv *PrivateKey) Public() crypto.PublicKey {
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700  88) 	return &priv.PublicKey
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700  89) }
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700  90) 
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  91) // Equal reports whether priv and x have the same value.
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  92) //
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  93) // See PublicKey.Equal for details on how Curve is compared.
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  94) func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool {
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  95) 	xx, ok := x.(*PrivateKey)
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  96) 	if !ok {
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  97) 		return false
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  98) 	}
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400  99) 	return priv.PublicKey.Equal(&xx.PublicKey) && priv.D.Cmp(xx.D) == 0
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400 100) }
a8e83d51a0c src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2020-04-30 23:52:48 -0400 101) 
507ca082d11 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-10-14 11:43:17 -0700 102) // Sign signs digest with priv, reading randomness from rand. The opts argument
507ca082d11 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-10-14 11:43:17 -0700 103) // is not currently used but, in keeping with the crypto.Signer interface,
507ca082d11 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-10-14 11:43:17 -0700 104) // should be the hash function used to digest the message.
507ca082d11 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-10-14 11:43:17 -0700 105) //
507ca082d11 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-10-14 11:43:17 -0700 106) // This method implements crypto.Signer, which is an interface to support keys
507ca082d11 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-10-14 11:43:17 -0700 107) // where the private part is kept in, for example, a hardware module. Common
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 108) // uses can use the SignASN1 function in this package directly.
507ca082d11 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-10-14 11:43:17 -0700 109) func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error) {
507ca082d11 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-10-14 11:43:17 -0700 110) 	r, s, err := Sign(rand, priv, digest)
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700 111) 	if err != nil {
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700 112) 		return nil, err
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700 113) 	}
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700 114) 
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 115) 	var b cryptobyte.Builder
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 116) 	b.AddASN1(asn1.SEQUENCE, func(b *cryptobyte.Builder) {
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 117) 		b.AddASN1BigInt(r)
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 118) 		b.AddASN1BigInt(s)
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 119) 	})
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 120) 	return b.Bytes()
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700 121) }
7f2e68e9822 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-08-29 12:36:30 -0700 122) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 123) var one = new(big.Int).SetInt64(1)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 124) 
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 125) // randFieldElement returns a random element of the order of the given
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 126) // curve using the procedure given in FIPS 186-4, Appendix B.5.1.
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 127) func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error) {
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 128) 	params := c.Params()
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 129) 	// Note that for P-521 this will actually be 63 bits more than the order, as
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 130) 	// division rounds down, but the extra bit is inconsequential.
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 131) 	b := make([]byte, params.BitSize/8+8) // TODO: use params.N.BitLen()
9f1394d2702 src/pkg/crypto/ecdsa/ecdsa.go (<dchest@gmail.com>    2011-04-05 17:11:31 -0400 132) 	_, err = io.ReadFull(rand, b)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 133) 	if err != nil {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 134) 		return
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 135) 	}
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 136) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 137) 	k = new(big.Int).SetBytes(b)
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 138) 	n := new(big.Int).Sub(params.N, one)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 139) 	k.Mod(k, n)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 140) 	k.Add(k, one)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 141) 	return
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 142) }
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 143) 
03640c58e3d src/pkg/crypto/ecdsa/ecdsa.go (<bradfitz@golang.org> 2013-04-13 23:09:08 -0700 144) // GenerateKey generates a public and private key pair.
351c15f1cee src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-02-28 15:52:49 -0800 145) func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error) {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 146) 	k, err := randFieldElement(c, rand)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 147) 	if err != nil {
351c15f1cee src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-02-28 15:52:49 -0800 148) 		return nil, err
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 149) 	}
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 150) 
351c15f1cee src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-02-28 15:52:49 -0800 151) 	priv := new(PrivateKey)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 152) 	priv.PublicKey.Curve = c
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 153) 	priv.D = k
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 154) 	priv.PublicKey.X, priv.PublicKey.Y = c.ScalarBaseMult(k.Bytes())
351c15f1cee src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-02-28 15:52:49 -0800 155) 	return priv, nil
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 156) }
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 157) 
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 158) // hashToInt converts a hash value to an integer. Per FIPS 186-4, Section 6.4,
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 159) // we use the left-most bits of the hash to match the bit-length of the order of
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 160) // the curve. This also performs Step 5 of SEC 1, Version 2.0, Section 4.1.3.
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 161) func hashToInt(hash []byte, c elliptic.Curve) *big.Int {
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 162) 	orderBits := c.Params().N.BitLen()
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 163) 	orderBytes := (orderBits + 7) / 8
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 164) 	if len(hash) > orderBytes {
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 165) 		hash = hash[:orderBytes]
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 166) 	}
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 167) 
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 168) 	ret := new(big.Int).SetBytes(hash)
477d7b16630 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-05-22 10:17:39 -0400 169) 	excess := len(hash)*8 - orderBits
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 170) 	if excess > 0 {
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 171) 		ret.Rsh(ret, uint(excess))
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 172) 	}
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 173) 	return ret
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 174) }
7b094182e42 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-16 10:42:41 -0400 175) 
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 176) // fermatInverse calculates the inverse of k in GF(P) using Fermat's method
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 177) // (exponentiation modulo P - 2, per Euler's theorem). This has better
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 178) // constant-time properties than Euclid's method (implemented in
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 179) // math/big.Int.ModInverse and FIPS 186-4, Appendix C.1) although math/big
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 180) // itself isn't strictly constant-time so it's not perfect.
f23d3ea85af src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-04-08 16:32:48 -0700 181) func fermatInverse(k, N *big.Int) *big.Int {
f23d3ea85af src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-04-08 16:32:48 -0700 182) 	two := big.NewInt(2)
f23d3ea85af src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-04-08 16:32:48 -0700 183) 	nMinus2 := new(big.Int).Sub(N, two)
f23d3ea85af src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-04-08 16:32:48 -0700 184) 	return new(big.Int).Exp(k, nMinus2, N)
f23d3ea85af src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-04-08 16:32:48 -0700 185) }
f23d3ea85af src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2014-04-08 16:32:48 -0700 186) 
d7c699d9935 src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-04-05 20:40:40 +0000 187) var errZeroParam = errors.New("zero parameter")
d7c699d9935 src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-04-05 20:40:40 +0000 188) 
cc6f5f6ce1d src/crypto/ecdsa/ecdsa.go     (<nharper@google.com>  2016-06-29 11:18:01 -0700 189) // Sign signs a hash (which should be the result of hashing a larger message)
cc6f5f6ce1d src/crypto/ecdsa/ecdsa.go     (<nharper@google.com>  2016-06-29 11:18:01 -0700 190) // using the private key, priv. If the hash is longer than the bit-length of the
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 191) // private key's curve order, the hash will be truncated to that length. It
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 192) // returns the signature as a pair of integers. Most applications should use
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 193) // SignASN1 instead of dealing directly with r, s.
c2049d2dfee src/pkg/crypto/ecdsa/ecdsa.go (<rsc@golang.org>      2011-11-01 22:04:37 -0400 194) func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {
6269dcdc24d src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-09-18 14:49:21 -0700 195) 	randutil.MaybeReadByte(rand)
6269dcdc24d src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2017-09-18 14:49:21 -0700 196) 
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 197) 	// This implementation derives the nonce from an AES-CTR CSPRNG keyed by:
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 198) 	//
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 199) 	//    SHA2-512(priv.D || entropy || hash)[:32]
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 200) 	//
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 201) 	// The CSPRNG key is indifferentiable from a random oracle as shown in
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 202) 	// [Coron], the AES-CTR stream is indifferentiable from a random oracle
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 203) 	// under standard cryptographic assumptions (see [Larsson] for examples).
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 204) 	//
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 205) 	// [Coron]: https://cs.nyu.edu/~dodis/ps/merkle.pdf
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 206) 	// [Larsson]: https://web.archive.org/web/20040719170906/https://www.nada.kth.se/kurser/kth/2D1441/semteo03/lecturenotes/assump.pdf
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 207) 
0a5ca2422f1 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-09-27 14:40:06 -0400 208) 	// Get 256 bits of entropy from rand.
0a5ca2422f1 src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-09-27 14:40:06 -0400 209) 	entropy := make([]byte, 32)
123b38e1053 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2015-03-16 16:42:12 -0700 210) 	_, err = io.ReadFull(rand, entropy)
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 211) 	if err != nil {
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 212) 		return
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 213) 	}
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 214) 
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 215) 	// Initialize an SHA-512 hash context; digest...
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 216) 	md := sha512.New()
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 217) 	md.Write(priv.D.Bytes()) // the private key,
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 218) 	md.Write(entropy)        // the entropy,
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 219) 	md.Write(hash)           // and the input hash;
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 220) 	key := md.Sum(nil)[:32]  // and compute ChopMD-256(SHA-512),
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 221) 	// which is an indifferentiable MAC.
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 222) 
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 223) 	// Create an AES-CTR instance to use as a CSPRNG.
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 224) 	block, err := aes.NewCipher(key)
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 225) 	if err != nil {
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 226) 		return nil, nil, err
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 227) 	}
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 228) 
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 229) 	// Create a CSPRNG that xors a stream of zeros with
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 230) 	// the output of the AES-CTR instance.
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 231) 	csprng := cipher.StreamReader{
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 232) 		R: zeroReader,
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 233) 		S: cipher.NewCTR(block, []byte(aesIV)),
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 234) 	}
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 235) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 236) 	c := priv.PublicKey.Curve
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 237) 	return sign(priv, &csprng, c, hash)
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 238) }
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 239) 
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 240) func signGeneric(priv *PrivateKey, csprng *cipher.StreamReader, c elliptic.Curve, hash []byte) (r, s *big.Int, err error) {
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 241) 	// SEC 1, Version 2.0, Section 4.1.3
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 242) 	N := c.Params().N
d7c699d9935 src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-04-05 20:40:40 +0000 243) 	if N.Sign() == 0 {
d7c699d9935 src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-04-05 20:40:40 +0000 244) 		return nil, nil, errZeroParam
d7c699d9935 src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-04-05 20:40:40 +0000 245) 	}
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 246) 	var k, kInv *big.Int
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 247) 	for {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 248) 		for {
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 249) 			k, err = randFieldElement(c, *csprng)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 250) 			if err != nil {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 251) 				r = nil
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 252) 				return
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 253) 			}
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 254) 
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 255) 			if in, ok := priv.Curve.(invertible); ok {
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 256) 				kInv = in.Inverse(k)
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 257) 			} else {
d7c699d9935 src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-04-05 20:40:40 +0000 258) 				kInv = fermatInverse(k, N) // N != 0
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 259) 			}
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 260) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 261) 			r, _ = priv.Curve.ScalarBaseMult(k.Bytes())
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 262) 			r.Mod(r, N)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 263) 			if r.Sign() != 0 {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 264) 				break
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 265) 			}
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 266) 		}
943df4f6295 src/crypto/ecdsa/ecdsa.go     (<mike.munday@ibm.com> 2019-10-16 21:49:09 +0100 267) 
943df4f6295 src/crypto/ecdsa/ecdsa.go     (<mike.munday@ibm.com> 2019-10-16 21:49:09 +0100 268) 		e := hashToInt(hash, c)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 269) 		s = new(big.Int).Mul(priv.D, r)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 270) 		s.Add(s, e)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 271) 		s.Mul(s, kInv)
d7c699d9935 src/crypto/ecdsa/ecdsa.go     (<bradfitz@golang.org> 2016-04-05 20:40:40 +0000 272) 		s.Mod(s, N) // N != 0
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 273) 		if s.Sign() != 0 {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 274) 			break
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 275) 		}
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 276) 	}
943df4f6295 src/crypto/ecdsa/ecdsa.go     (<mike.munday@ibm.com> 2019-10-16 21:49:09 +0100 277) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 278) 	return
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 279) }
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 280) 
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 281) // SignASN1 signs a hash (which should be the result of hashing a larger message)
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 282) // using the private key, priv. If the hash is longer than the bit-length of the
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 283) // private key's curve order, the hash will be truncated to that length. It
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 284) // returns the ASN.1 encoded signature.
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 285) func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error) {
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 286) 	return priv.Sign(rand, hash, nil)
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 287) }
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 288) 
abe384f68a8 src/pkg/crypto/ecdsa/ecdsa.go (<r@golang.org>        2013-07-23 11:59:49 +1000 289) // Verify verifies the signature in r, s of hash using the public key, pub. Its
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 290) // return value records whether the signature is valid. Most applications should
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 291) // use VerifyASN1 instead of dealing directly with r, s.
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 292) func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 293) 	c := pub.Curve
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 294) 	N := c.Params().N
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 295) 
b30fcbc9f59 src/crypto/ecdsa/ecdsa.go     (<agl@golang.org>      2016-04-14 13:52:56 -0700 296) 	if r.Sign() <= 0 || s.Sign() <= 0 {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 297) 		return false
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 298) 	}
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 299) 	if r.Cmp(N) >= 0 || s.Cmp(N) >= 0 {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 300) 		return false
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 301) 	}
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 302) 	return verify(pub, c, hash, r, s)
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 303) }
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 304) 
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 305) func verifyGeneric(pub *PublicKey, c elliptic.Curve, hash []byte, r, s *big.Int) bool {
8384fe86a5b src/crypto/ecdsa/ecdsa.go     (<filippo@golang.org>  2021-10-30 00:27:51 -0400 306) 	// SEC 1, Version 2.0, Section 4.1.4
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 307) 	e := hashToInt(hash, c)
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 308) 	var w *big.Int
a637ee1970a src/crypto/ecdsa/ecdsa.go     (<ruixin.bao@ibm.com>  2020-04-15 16:50:50 -0400 309) 	N := c.Params().N
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 310) 	if in, ok := c.(invertible); ok {
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 311) 		w = in.Inverse(s)
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 312) 	} else {
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 313) 		w = new(big.Int).ModInverse(s, N)
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 314) 	}
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 315) 
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 316) 	u1 := e.Mul(e, w)
728f1913191 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-08-03 15:42:14 -0400 317) 	u1.Mod(u1, N)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 318) 	u2 := w.Mul(r, w)
728f1913191 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-08-03 15:42:14 -0400 319) 	u2.Mod(u2, N)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 320) 
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 321) 	// Check if implements S1*g + S2*p
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 322) 	var x, y *big.Int
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 323) 	if opt, ok := c.(combinedMult); ok {
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 324) 		x, y = opt.CombinedMult(pub.X, pub.Y, u1.Bytes(), u2.Bytes())
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 325) 	} else {
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 326) 		x1, y1 := c.ScalarBaseMult(u1.Bytes())
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 327) 		x2, y2 := c.ScalarMult(pub.X, pub.Y, u2.Bytes())
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 328) 		x, y = c.Add(x1, y1, x2, y2)
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 329) 	}
7bacfc640fb src/crypto/ecdsa/ecdsa.go     (<vlad@cloudflare.com> 2015-04-17 06:10:35 -0700 330) 
728f1913191 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-08-03 15:42:14 -0400 331) 	if x.Sign() == 0 && y.Sign() == 0 {
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 332) 		return false
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 333) 	}
247799ce8a0 src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2012-01-19 08:39:03 -0500 334) 	x.Mod(x, N)
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 335) 	return x.Cmp(r) == 0
f422242065d src/pkg/crypto/ecdsa/ecdsa.go (<agl@golang.org>      2011-03-10 09:42:34 -0500 336) }
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 337) 
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 338) // VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 339) // public key, pub. Its return value records whether the signature is valid.
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 340) func VerifyASN1(pub *PublicKey, hash, sig []byte) bool {
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 341) 	var (
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 342) 		r, s  = &big.Int{}, &big.Int{}
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 343) 		inner cryptobyte.String
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 344) 	)
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 345) 	input := cryptobyte.String(sig)
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 346) 	if !input.ReadASN1(&inner, asn1.SEQUENCE) ||
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 347) 		!input.Empty() ||
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 348) 		!inner.ReadASN1Integer(r) ||
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 349) 		!inner.ReadASN1Integer(s) ||
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 350) 		!inner.Empty() {
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 351) 		return false
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 352) 	}
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 353) 	return Verify(pub, hash, r, s)
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 354) }
8c09e8af363 src/crypto/ecdsa/ecdsa.go     (<katie@golang.org>    2020-02-05 15:19:41 -0500 355) 
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 356) type zr struct {
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 357) 	io.Reader
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 358) }
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 359) 
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 360) // Read replaces the contents of dst with zeros.
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 361) func (z *zr) Read(dst []byte) (n int, err error) {
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 362) 	for i := range dst {
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 363) 		dst[i] = 0
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 364) 	}
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 365) 	return len(dst), nil
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 366) }
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 367) 
a8049f58f9e src/crypto/ecdsa/ecdsa.go     (<coruus@gmail.com>    2015-01-26 23:00:21 -0800 368) var zeroReader = &zr{}
