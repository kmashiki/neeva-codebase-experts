a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   1) // Copyright 2020 The Go Authors. All rights reserved.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   2) // Use of this source code is governed by a BSD-style
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   3) // license that can be found in the LICENSE file.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   4) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   5) package ecdsa
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   6) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   7) import (
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   8) 	"crypto/cipher"
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400   9) 	"crypto/elliptic"
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  10) 	"internal/cpu"
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  11) 	"math/big"
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  12) )
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  13) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  14) // kdsa invokes the "compute digital signature authentication"
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  15) // instruction with the given function code and 4096 byte
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  16) // parameter block.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  17) //
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  18) // The return value corresponds to the condition code set by the
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  19) // instruction. Interrupted invocations are handled by the
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  20) // function.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  21) //go:noescape
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  22) func kdsa(fc uint64, params *[4096]byte) (errn uint64)
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  23) 
1108cbe60b8 (<filippo@golang.org> 2021-04-30 23:10:26 -0400  24) // testingDisableKDSA forces the generic fallback path. It must only be set in tests.
1108cbe60b8 (<filippo@golang.org> 2021-04-30 23:10:26 -0400  25) var testingDisableKDSA bool
1108cbe60b8 (<filippo@golang.org> 2021-04-30 23:10:26 -0400  26) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  27) // canUseKDSA checks if KDSA instruction is available, and if it is, it checks
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  28) // the name of the curve to see if it matches the curves supported(P-256, P-384, P-521).
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  29) // Then, based on the curve name, a function code and a block size will be assigned.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  30) // If KDSA instruction is not available or if the curve is not supported, canUseKDSA
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  31) // will set ok to false.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  32) func canUseKDSA(c elliptic.Curve) (functionCode uint64, blockSize int, ok bool) {
1108cbe60b8 (<filippo@golang.org> 2021-04-30 23:10:26 -0400  33) 	if testingDisableKDSA {
1108cbe60b8 (<filippo@golang.org> 2021-04-30 23:10:26 -0400  34) 		return 0, 0, false
1108cbe60b8 (<filippo@golang.org> 2021-04-30 23:10:26 -0400  35) 	}
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  36) 	if !cpu.S390X.HasECDSA {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  37) 		return 0, 0, false
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  38) 	}
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  39) 	switch c.Params().Name {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  40) 	case "P-256":
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  41) 		return 1, 32, true
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  42) 	case "P-384":
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  43) 		return 2, 48, true
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  44) 	case "P-521":
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  45) 		return 3, 80, true
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  46) 	}
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  47) 	return 0, 0, false // A mismatch
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  48) }
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  49) 
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  50) func hashToBytes(dst, hash []byte, c elliptic.Curve) {
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  51) 	l := len(dst)
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  52) 	if n := c.Params().N.BitLen(); n == l*8 {
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  53) 		// allocation free path for curves with a length that is a whole number of bytes
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  54) 		if len(hash) >= l {
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  55) 			// truncate hash
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  56) 			copy(dst, hash[:l])
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  57) 			return
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  58) 		}
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  59) 		// pad hash with leading zeros
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  60) 		p := l - len(hash)
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  61) 		for i := 0; i < p; i++ {
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  62) 			dst[i] = 0
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  63) 		}
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  64) 		copy(dst[p:], hash)
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  65) 		return
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  66) 	}
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  67) 	// TODO(mundaym): avoid hashToInt call here
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400  68) 	hashToInt(hash, c).FillBytes(dst)
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  69) }
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  70) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  71) func sign(priv *PrivateKey, csprng *cipher.StreamReader, c elliptic.Curve, hash []byte) (r, s *big.Int, err error) {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  72) 	if functionCode, blockSize, ok := canUseKDSA(c); ok {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  73) 		for {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  74) 			var k *big.Int
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  75) 			k, err = randFieldElement(c, *csprng)
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  76) 			if err != nil {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  77) 				return nil, nil, err
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  78) 			}
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  79) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  80) 			// The parameter block looks like the following for sign.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  81) 			// 	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  82) 			// 	|   Signature(R)      |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  83) 			//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  84) 			//	|   Signature(S)      |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  85) 			//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  86) 			//	|   Hashed Message    |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  87) 			//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  88) 			//	|   Private Key       |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  89) 			//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  90) 			//	|   Random Number     |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  91) 			//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  92) 			//	|                     |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  93) 			//	|        ...          |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  94) 			//	|                     |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  95) 			//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  96) 			// The common components(signatureR, signatureS, hashedMessage, privateKey and
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  97) 			// random number) each takes block size of bytes. The block size is different for
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  98) 			// different curves and is set by canUseKDSA function.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400  99) 			var params [4096]byte
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 100) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 101) 			// Copy content into the parameter block. In the sign case,
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 102) 			// we copy hashed message, private key and random number into
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 103) 			// the parameter block.
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 104) 			hashToBytes(params[2*blockSize:3*blockSize], hash, c)
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 105) 			priv.D.FillBytes(params[3*blockSize : 4*blockSize])
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 106) 			k.FillBytes(params[4*blockSize : 5*blockSize])
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 107) 			// Convert verify function code into a sign function code by adding 8.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 108) 			// We also need to set the 'deterministic' bit in the function code, by
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 109) 			// adding 128, in order to stop the instruction using its own random number
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 110) 			// generator in addition to the random number we supply.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 111) 			switch kdsa(functionCode+136, &params) {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 112) 			case 0: // success
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 113) 				r = new(big.Int)
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 114) 				r.SetBytes(params[:blockSize])
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 115) 				s = new(big.Int)
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 116) 				s.SetBytes(params[blockSize : 2*blockSize])
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 117) 				return
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 118) 			case 1: // error
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 119) 				return nil, nil, errZeroParam
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 120) 			case 2: // retry
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 121) 				continue
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 122) 			}
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 123) 			panic("unreachable")
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 124) 		}
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 125) 	}
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 126) 	return signGeneric(priv, csprng, c, hash)
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 127) }
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 128) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 129) func verify(pub *PublicKey, c elliptic.Curve, hash []byte, r, s *big.Int) bool {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 130) 	if functionCode, blockSize, ok := canUseKDSA(c); ok {
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 131) 		// The parameter block looks like the following for verify:
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 132) 		// 	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 133) 		// 	|   Signature(R)      |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 134) 		//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 135) 		//	|   Signature(S)      |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 136) 		//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 137) 		//	|   Hashed Message    |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 138) 		//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 139) 		//	|   Public Key X      |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 140) 		//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 141) 		//	|   Public Key Y      |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 142) 		//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 143) 		//	|                     |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 144) 		//	|        ...          |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 145) 		//	|                     |
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 146) 		//	+---------------------+
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 147) 		// The common components(signatureR, signatureS, hashed message, public key X,
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 148) 		// and public key Y) each takes block size of bytes. The block size is different for
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 149) 		// different curves and is set by canUseKDSA function.
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 150) 		var params [4096]byte
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 151) 
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 152) 		// Copy content into the parameter block. In the verify case,
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 153) 		// we copy signature (r), signature(s), hashed message, public key x component,
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 154) 		// and public key y component into the parameter block.
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 155) 		r.FillBytes(params[0*blockSize : 1*blockSize])
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 156) 		s.FillBytes(params[1*blockSize : 2*blockSize])
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 157) 		hashToBytes(params[2*blockSize:3*blockSize], hash, c)
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 158) 		pub.X.FillBytes(params[3*blockSize : 4*blockSize])
54a112d7197 (<ruixin.bao@ibm.com> 2020-09-29 15:55:19 -0400 159) 		pub.Y.FillBytes(params[4*blockSize : 5*blockSize])
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 160) 		return kdsa(functionCode, &params) == 0
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 161) 	}
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 162) 	return verifyGeneric(pub, c, hash, r, s)
a637ee1970a (<ruixin.bao@ibm.com> 2020-04-15 16:50:50 -0400 163) }
